% ACT 3: THE BREAKTHROUGH (6 slides)
% Theme: From human insight to technical solution
% Pattern: Visual + Detailed, with code examples
% NO UNVERIFIED NUMBERS

\section{Act 3: The Breakthrough}

% Slide 9: Human Introspection
\begin{frame}[t]{The Key Question: How Do YOU Ensure Data Consistency?}
\textbf{Before we design a solution, observe your own behavior:}

\vspace{0.5cm}

\begin{columns}[T]
\column{0.48\textwidth}
\textcolor{mlpurple}{\textbf{Scenario 1: Filling a Form}}

\small
You're entering customer data into a database:
\begin{itemize}
\item \textbf{First}: Check what fields are required
\item \textbf{Then}: Enter data matching field types
\item \textbf{Validate}: Form rejects if types don't match
\item \textbf{Fix}: Correct errors before submitting
\end{itemize}

\vspace{0.2cm}
\textbf{Key observation}: You \textit{validate against a schema} before submission

\column{0.48\textwidth}
\textcolor{mlpurple}{\textbf{Scenario 2: Creating a Spreadsheet}}

\small
You're standardizing product data:
\begin{itemize}
\item \textbf{First}: Define column headers (schema)
\item \textbf{Then}: Enter data in correct columns
\item \textbf{Validate}: Check types, ranges, required fields
\item \textbf{Enforce}: Use data validation rules
\end{itemize}

\vspace{0.2cm}
\textbf{Key observation}: You \textit{define structure first}, then fill it
\end{columns}

\vspace{0.5cm}

\begin{center}
\textcolor{mlgreen}{\Large \textbf{The Pattern}}
\end{center}

\begin{center}
\textbf{Humans ensure consistency by:}\\
1. Defining schema/structure FIRST\\
2. Validating data against that structure\\
3. Rejecting invalid entries\\
4. Fixing errors before proceeding
\end{center}

\bottomnote{Human introspection reveals the solution: Structure-first, validate-always, reject-invalid approach}
\end{frame}

% Slide 10: Visual - The Hypothesis
\begin{frame}[t]{The Hypothesis: Structure First, Then Generate}
\vspace{-0.3cm}
\begin{center}
\includegraphics[width=0.85\textwidth]{prompts_vs_schemas.pdf}
\end{center}

\begin{center}
\textbf{Key Insight}: Prompts suggest format (weak), schemas enforce structure (strong) - enforcement beats suggestion
\end{center}

\bottomnote{The breakthrough hypothesis: If we define schema first, AI can be forced to conform rather than suggest}
\end{frame}

% Slide 11: Detail - Zero-Jargon Explanation
\begin{frame}[t]{The Solution in Plain English: What It Does and Why It Works}
\small
\begin{columns}[T]
\column{0.49\textwidth}
\raggedright
\textbf{What It Does (No Technical Terms)}:

\vspace{0.2cm}
\textbf{Step 1: Define Contract}
\begin{itemize}
\item List exactly what fields you need
\item Specify types (text, number, date)
\item Mark which fields are required
\item Like a database table definition
\end{itemize}

\vspace{0.2cm}
\textbf{Step 2: Send to AI}
\begin{itemize}
\item Give AI the contract along with data
\item AI must return data matching contract
\item API-level enforcement (not just prompt)
\item AI literally cannot return wrong format
\end{itemize}

\vspace{0.2cm}
\textbf{Step 3: Validate and Recover}
\begin{itemize}
\item Check all required fields present
\item Verify types match specification
\item Retry if validation fails
\item Log errors for debugging
\end{itemize}

\column{0.49\textwidth}
\raggedright
\textbf{Why It Works}:

\vspace{0.2cm}
\textbf{Enforcement Mechanism}
\begin{itemize}
\item Not a suggestion - it's a requirement
\item API rejects non-conforming output
\item Like database rejecting bad INSERT
\item Guaranteed structure or explicit error
\end{itemize}

\vspace{0.2cm}
\textbf{Predictable Failures}
\begin{itemize}
\item Failures are caught immediately
\item Error messages are specific
\item Retry logic can handle failures
\item No silent corruption
\end{itemize}

\vspace{0.2cm}
\textbf{System Integration}
\begin{itemize}
\item Output is parseable (guaranteed)
\item Fields match database schema
\item Types are validated
\item Downstream systems accept input
\end{itemize}
\end{columns}

\vspace{0.3cm}
\begin{center}
\textcolor{mlpurple}{\textbf{Core Principle:}} Contract → Generate → Validate (not Hope → Generate → Fix)
\end{center}

\bottomnote{Zero-jargon explanation reveals the mechanism: Define structure, enforce at API level, validate before accepting}
\end{frame}

% Slide 12: Visual - The 3-Layer Architecture
\begin{frame}[t]{The 3-Layer Architecture: Schema, Generation, Validation}
\vspace{-0.3cm}
\begin{center}
\includegraphics[width=0.85\textwidth]{three_layer_architecture.pdf}
\end{center}

\begin{center}
\textbf{Key Insight}: Three layers working together transform unreliable text into reliable structured data
\end{center}

\bottomnote{Complete architecture: Schema defines contract, Function calling enforces it, Validation catches edge cases}
\end{frame}

% Slide 13: Code Example - Schema Definition
\begin{frame}[fragile,t]{Layer 1: Schema Definition with Pydantic}
\textbf{Real code defining a type-safe contract:}

\vspace{0.3cm}

\begin{lstlisting}[language=Python]
from pydantic import BaseModel, Field

class ProductExtraction(BaseModel):
    """Schema for structured product data extraction"""

    product_name: str = Field(
        description="Full product name"
    )

    price: float = Field(
        description="Price in USD",
        gt=0  # Must be positive
    )

    storage_gb: int = Field(
        description="Storage capacity in GB",
        ge=0  # Greater or equal to 0
    )

    confidence: float = Field(
        description="Extraction confidence score",
        ge=0.0, le=1.0  # Between 0 and 1
    )
\end{lstlisting}

\vspace{0.3cm}

\textbf{What this achieves}:
\begin{itemize}
\item Type safety: price must be float, storage must be int
\item Validation: automatic type checking and range constraints
\item Documentation: each field has clear description
\item Contract: downstream code knows exactly what to expect
\end{itemize}

\bottomnote{Pydantic schemas create type-safe contracts that validate automatically}
\end{frame}

% Slide 14: Code Example - Function Calling + Validation
\begin{frame}[fragile,t]{Layers 2 \& 3: Function Calling with Validation}
\textbf{Real code enforcing structure and validating output:}

\vspace{0.3cm}

\begin{lstlisting}[language=Python]
from openai import OpenAI

client = OpenAI()

# Convert Pydantic schema to JSON schema
schema = ProductExtraction.model_json_schema()

# Layer 2: Function calling (enforcement at API level)
response = client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": product_text}],
    tools=[{
        "type": "function",
        "function": {
            "name": "extract_product",
            "description": "Extract product information",
            "parameters": schema
        }
    }]
)

# Layer 3: Validation and recovery
try:
    # Extract structured data
    args = response.choices[0].message.tool_calls[0].function.arguments

    # Validate against schema
    product = ProductExtraction.model_validate_json(args)

    # Success - guaranteed structure
    print(f"Product: {product.product_name}, Price: ${product.price}")

except Exception as e:
    # Validation failed - retry or escalate
    print(f"Validation error: {e}")
    # Implement retry logic here
\end{lstlisting}

\bottomnote{Function calling enforces schema at API level, validation catches any edge cases, retry handles failures}
\end{frame}

% Slide 15: Visual - Before/After Comparison (Qualitative)
\begin{frame}[t]{Before and After: The Transformation (Qualitative)}
\vspace{-0.3cm}
\begin{center}
\includegraphics[width=0.85\textwidth]{before_after_qualitative.pdf}
\end{center}

\begin{center}
\textcolor{mlgreen}{\textbf{Structured outputs with validation deliver reliable, production-ready results where prompt engineering alone breaks down}}
\end{center}

\vspace{0.3cm}

\begin{columns}[T]
\column{0.48\textwidth}
\small
\textcolor{mlred}{\textbf{Before: Prompt Engineering}}
\begin{itemize}
\item Works on simple cases
\item Breaks on complex, messy data
\item Variable output formats
\item Unpredictable failures
\item Manual intervention needed
\item Not production-ready
\end{itemize}

\column{0.48\textwidth}
\small
\textcolor{mlgreen}{\textbf{After: Structured Outputs}}
\begin{itemize}
\item Works across complexity levels
\item Handles messy, real-world data
\item Guaranteed consistent format
\item Predictable error modes
\item Automatic retry and recovery
\item Production-grade reliability
\end{itemize}
\end{columns}

\bottomnote{Qualitative improvement: From unreliable prototypes to production-ready systems through structure and validation}
\end{frame}
